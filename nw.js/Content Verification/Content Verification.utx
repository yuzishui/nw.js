<Transmate Version="1.0.0.0"><head utxVersion="1.0u" Tag="0" CreationTime="2016/3/9 20:42:51" FileIndex="0" SourceLanguage="英语" TargetLanguage="中文简体" SourceDocumentPath="D:\workspace_github\nw.js\nw.js\Content Verification\Content Verification.txt" RowIndex="0" HideOrNot="False" TermFileType="" TermFileId="" TheOriginalWord="353" TheNumberWords="0" ToTranslate="0" FileType="0" MemFileOutType="" MemFileOutId="" MemFileInType="" MemFileInId="" LitePath="D:\workspace_github\nw.js\nw.js\FileInformation.ueprj" CustomTermPath="" PreviewPath="D:\workspace_github\nw.js\nw.js\Content Verification\Content VerificationPreview.html"><links /></head><body><tu PI="1" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl># Content Verification</sl><tl /><tsl /><prv /><sfl># Content Verification</sfl></tu><tu PI="2" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>---</sl><tl /><tsl /><prv /><sfl>---</sfl></tu><tu PI="3" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>[TOC]</sl><tl /><tsl /><prv /><sfl>[TOC]</sfl></tu><tu PI="4" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>The "content verification" feature, or "app signing", prevents loading unsigned files with your official binary. </sl><tl /><tsl /><prv /><sfl>The "content verification" feature, or "app signing", prevents loading unsigned files with your official binary. Given a keypair, 'verified_contents.json' is the signature for the application files. It's created with the tool 'sign.py' and the private key (private_key.pem file). The public key is built into NW.js binary. To run the signed application, use `nw --verify-content=enforce_strict .` in the application directory. It will show the simple page. In the next, try to modify index.html a little bit and run it again. NW will report the file is corrupted and quit immediately.</sfl></tu><tu PI="4" MatchPercent="" Bindex="2" IsVisible="False" TranStatus="" StateTranslation="False"><sl>Given a keypair, 'verified_contents.json' is the signature for the application files. </sl><tl /><tsl /><prv /><sfl>The "content verification" feature, or "app signing", prevents loading unsigned files with your official binary. Given a keypair, 'verified_contents.json' is the signature for the application files. It's created with the tool 'sign.py' and the private key (private_key.pem file). The public key is built into NW.js binary. To run the signed application, use `nw --verify-content=enforce_strict .` in the application directory. It will show the simple page. In the next, try to modify index.html a little bit and run it again. NW will report the file is corrupted and quit immediately.</sfl></tu><tu PI="4" MatchPercent="" Bindex="3" IsVisible="False" TranStatus="" StateTranslation="False"><sl>It's created with the tool 'sign.py' and the private key (private_key.pem file). </sl><tl /><tsl /><prv /><sfl>The "content verification" feature, or "app signing", prevents loading unsigned files with your official binary. Given a keypair, 'verified_contents.json' is the signature for the application files. It's created with the tool 'sign.py' and the private key (private_key.pem file). The public key is built into NW.js binary. To run the signed application, use `nw --verify-content=enforce_strict .` in the application directory. It will show the simple page. In the next, try to modify index.html a little bit and run it again. NW will report the file is corrupted and quit immediately.</sfl></tu><tu PI="4" MatchPercent="" Bindex="4" IsVisible="False" TranStatus="" StateTranslation="False"><sl>The public key is built into NW.js binary. </sl><tl /><tsl /><prv /><sfl>The "content verification" feature, or "app signing", prevents loading unsigned files with your official binary. Given a keypair, 'verified_contents.json' is the signature for the application files. It's created with the tool 'sign.py' and the private key (private_key.pem file). The public key is built into NW.js binary. To run the signed application, use `nw --verify-content=enforce_strict .` in the application directory. It will show the simple page. In the next, try to modify index.html a little bit and run it again. NW will report the file is corrupted and quit immediately.</sfl></tu><tu PI="4" MatchPercent="" Bindex="5" IsVisible="False" TranStatus="" StateTranslation="False"><sl>To run the signed application, use `nw --verify-content=enforce_strict .` in the application directory. </sl><tl /><tsl /><prv /><sfl>The "content verification" feature, or "app signing", prevents loading unsigned files with your official binary. Given a keypair, 'verified_contents.json' is the signature for the application files. It's created with the tool 'sign.py' and the private key (private_key.pem file). The public key is built into NW.js binary. To run the signed application, use `nw --verify-content=enforce_strict .` in the application directory. It will show the simple page. In the next, try to modify index.html a little bit and run it again. NW will report the file is corrupted and quit immediately.</sfl></tu><tu PI="4" MatchPercent="" Bindex="6" IsVisible="False" TranStatus="" StateTranslation="False"><sl>It will show the simple page. </sl><tl /><tsl /><prv /><sfl>The "content verification" feature, or "app signing", prevents loading unsigned files with your official binary. Given a keypair, 'verified_contents.json' is the signature for the application files. It's created with the tool 'sign.py' and the private key (private_key.pem file). The public key is built into NW.js binary. To run the signed application, use `nw --verify-content=enforce_strict .` in the application directory. It will show the simple page. In the next, try to modify index.html a little bit and run it again. NW will report the file is corrupted and quit immediately.</sfl></tu><tu PI="4" MatchPercent="" Bindex="7" IsVisible="False" TranStatus="" StateTranslation="False"><sl>In the next, try to modify index.html a little bit and run it again. </sl><tl /><tsl /><prv /><sfl>The "content verification" feature, or "app signing", prevents loading unsigned files with your official binary. Given a keypair, 'verified_contents.json' is the signature for the application files. It's created with the tool 'sign.py' and the private key (private_key.pem file). The public key is built into NW.js binary. To run the signed application, use `nw --verify-content=enforce_strict .` in the application directory. It will show the simple page. In the next, try to modify index.html a little bit and run it again. NW will report the file is corrupted and quit immediately.</sfl></tu><tu PI="4" MatchPercent="" Bindex="8" IsVisible="False" TranStatus="" StateTranslation="False"><sl>NW will report the file is corrupted and quit immediately.</sl><tl /><tsl /><prv /><sfl>The "content verification" feature, or "app signing", prevents loading unsigned files with your official binary. Given a keypair, 'verified_contents.json' is the signature for the application files. It's created with the tool 'sign.py' and the private key (private_key.pem file). The public key is built into NW.js binary. To run the signed application, use `nw --verify-content=enforce_strict .` in the application directory. It will show the simple page. In the next, try to modify index.html a little bit and run it again. NW will report the file is corrupted and quit immediately.</sfl></tu><tu PI="5" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>!!! </sl><tl /><tsl /><prv /><sfl>!!! note</sfl></tu><tu PI="5" MatchPercent="" Bindex="2" IsVisible="False" TranStatus="" StateTranslation="False"><sl>note</sl><tl /><tsl /><prv /><sfl>!!! note</sfl></tu><tu PI="6" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>    This feature doesn't prevent someone from hacking your app and loading it with other NW binaries. </sl><tl /><tsl /><prv /><sfl>    This feature doesn't prevent someone from hacking your app and loading it with other NW binaries. Consider writing some of your features with C++ and load it with Node.js module, NaCl or [compile your JS to binary with nwjc](Protect JavaScript Source Code.md)</sfl></tu><tu PI="6" MatchPercent="" Bindex="2" IsVisible="False" TranStatus="" StateTranslation="False"><sl>Consider writing some of your features with C++ and load it with Node.js module, NaCl or [compile your JS to binary with nwjc](Protect JavaScript Source Code.md)</sl><tl /><tsl /><prv /><sfl>    This feature doesn't prevent someone from hacking your app and loading it with other NW binaries. Consider writing some of your features with C++ and load it with Node.js module, NaCl or [compile your JS to binary with nwjc](Protect JavaScript Source Code.md)</sfl></tu><tu PI="7" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>## Sign an application</sl><tl /><tsl /><prv /><sfl>## Sign an application</sfl></tu><tu PI="8" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>To sign an application with the demo keypair, do the following:</sl><tl /><tsl /><prv /><sfl>To sign an application with the demo keypair, do the following:</sfl></tu><tu PI="9" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>1. change to application directory</sl><tl /><tsl /><prv /><sfl>1. change to application directory</sfl></tu><tu PI="10" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>2. make sure `verified_contents.json` or `computed_hashes.json` is not there (you can just remove them)</sl><tl /><tsl /><prv /><sfl>2. make sure `verified_contents.json` or `computed_hashes.json` is not there (you can just remove them)</sfl></tu><tu PI="11" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>3. run `payload.exe`; </sl><tl /><tsl /><prv /><sfl>3. run `payload.exe`; it will generate `payload.json`, which serves as input for `sign.py`</sfl></tu><tu PI="11" MatchPercent="" Bindex="2" IsVisible="False" TranStatus="" StateTranslation="False"><sl>it will generate `payload.json`, which serves as input for `sign.py`</sl><tl /><tsl /><prv /><sfl>3. run `payload.exe`; it will generate `payload.json`, which serves as input for `sign.py`</sfl></tu><tu PI="12" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>4. run `python sign.py &gt; /tmp/verified_contents.json` (it's important that the tmp destination directory is not application directory)</sl><tl /><tsl /><prv /><sfl>4. run `python sign.py &gt; /tmp/verified_contents.json` (it's important that the tmp destination directory is not application directory)</sfl></tu><tu PI="13" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>5. move the generated `verified_contents.json` file to application dir and it's done.</sl><tl /><tsl /><prv /><sfl>5. move the generated `verified_contents.json` file to application dir and it's done.</sfl></tu><tu PI="14" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>## Rebuild to use your own keypair</sl><tl /><tsl /><prv /><sfl>## Rebuild to use your own keypair</sfl></tu><tu PI="15" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>To use your own keypair you'll need to rebuild the NW binary. </sl><tl /><tsl /><prv /><sfl>To use your own keypair you'll need to rebuild the NW binary. And the argument for `--verify-content=` in the command line need to be set to `enforce_strict` by default in your build.</sfl></tu><tu PI="15" MatchPercent="" Bindex="2" IsVisible="False" TranStatus="" StateTranslation="False"><sl>And the argument for `--verify-content=` in the command line need to be set to `enforce_strict` by default in your build.</sl><tl /><tsl /><prv /><sfl>To use your own keypair you'll need to rebuild the NW binary. And the argument for `--verify-content=` in the command line need to be set to `enforce_strict` by default in your build.</sfl></tu><tu PI="16" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>1. generate your keypair: </sl><tl /><tsl /><prv /><sfl>1. generate your keypair: `openssl genrsa -out private_key.pem 2048`</sfl></tu><tu PI="16" MatchPercent="" Bindex="2" IsVisible="False" TranStatus="" StateTranslation="False"><sl>`openssl genrsa -out private_key.pem 2048`</sl><tl /><tsl /><prv /><sfl>1. generate your keypair: `openssl genrsa -out private_key.pem 2048`</sfl></tu><tu PI="17" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>(the output file contains both the private and public key)</sl><tl /><tsl /><prv /><sfl>(the output file contains both the private and public key)</sfl></tu><tu PI="18" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>2. run python convertkey.py; </sl><tl /><tsl /><prv /><sfl>2. run python convertkey.py; it will convert the public key to C source code.</sfl></tu><tu PI="18" MatchPercent="" Bindex="2" IsVisible="False" TranStatus="" StateTranslation="False"><sl>it will convert the public key to C source code.</sl><tl /><tsl /><prv /><sfl>2. run python convertkey.py; it will convert the public key to C source code.</sfl></tu><tu PI="19" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>3. put the generated source code in</sl><tl /><tsl /><prv /><sfl>3. put the generated source code in</sfl></tu><tu PI="20" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>`content/nw/src/nw_content_verifier_delegate.cc`; </sl><tl /><tsl /><prv /><sfl>`content/nw/src/nw_content_verifier_delegate.cc`; replace the default key.</sfl></tu><tu PI="20" MatchPercent="" Bindex="2" IsVisible="False" TranStatus="" StateTranslation="False"><sl>replace the default key.</sl><tl /><tsl /><prv /><sfl>`content/nw/src/nw_content_verifier_delegate.cc`; replace the default key.</sfl></tu><tu PI="21" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>4. change the default value for the command line argument: </sl><tl /><tsl /><prv /><sfl>4. change the default value for the command line argument: change line no.73 in that file to:</sfl></tu><tu PI="21" MatchPercent="" Bindex="2" IsVisible="False" TranStatus="" StateTranslation="False"><sl>change line no.73 in that file to:</sl><tl /><tsl /><prv /><sfl>4. change the default value for the command line argument: change line no.73 in that file to:</sfl></tu><tu PI="22" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>   `Mode experiment_value =  ContentVerifierDelegate::ENFORCE_STRICT;`</sl><tl /><tsl /><prv /><sfl>   `Mode experiment_value =  ContentVerifierDelegate::ENFORCE_STRICT;`</sfl></tu><tu PI="23" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>5. build the NW binary.</sl><tl /><tsl /><prv /><sfl>5. build the NW binary.</sfl></tu><tu PI="24" MatchPercent="" Bindex="1" IsVisible="False" TranStatus="" StateTranslation="False"><sl>Tools, sample application and the demo private key is under `tools/sign` directory. </sl><tl /><tsl /><prv /><sfl>Tools, sample application and the demo private key is under `tools/sign` directory. The demo private key is paired with the public key built into the official NW binaries.</sfl></tu><tu PI="24" MatchPercent="" Bindex="2" IsVisible="False" TranStatus="" StateTranslation="False"><sl>The demo private key is paired with the public key built into the official NW binaries.</sl><tl /><tsl /><prv /><sfl>Tools, sample application and the demo private key is under `tools/sign` directory. The demo private key is paired with the public key built into the official NW binaries.</sfl></tu></body></Transmate>